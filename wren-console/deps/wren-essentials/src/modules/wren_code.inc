// Generated automatically from src/modules/*.wren. Do not edit.
static const char* mirrorModuleSource =
"\n"
"// FIXME: Add cache.\n"
"\n"
"class Mirror {\n"
"  static reflect(reflectee) {\n"
"    var mirror = ObjectMirror\n"
"    if (reflectee is Class) mirror = ClassMirror\n"
"    if (reflectee is Fiber) mirror = FiberMirror\n"
"\n"
"    return mirror.new_(reflectee)\n"
"  }\n"
"}\n"
"\n"
"class ObjectMirror is Mirror {\n"
"  foreign static canInvoke(reflectee, methodName)\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  classMirror {\n"
"    if (_classMirror == null) _classMirror = Mirror.reflect(_reflectee.type)\n"
"    return _classMirror\n"
"  }\n"
"\n"
"  moduleMirror { classMirror.moduleMirror }\n"
"\n"
"  reflectee { _reflectee }\n"
"\n"
"  canInvoke(signature) { classMirror.hasMethod(signature) }\n"
"}\n"
"\n"
"class ClassMirror is ObjectMirror {\n"
"  foreign static allAttributes(reflectee)\n"
"  foreign static hasMethod(reflectee, signature)\n"
"  foreign static methodNames(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"    _moduleMirror = null\n"
"\n"
"    _methods = ClassMirror.methodNames(reflectee)\n"
"  }\n"
"\n"
"  moduleMirror { _moduleMirror }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(reflectee)\n"
"    return attr != null ? attr.self : null\n"
"  }\n"
"\n"
"  hasMethod(signature) { ClassMirror.hasMethod(reflectee, signature) }\n"
"\n"
"  methodNames { _methodNames }\n"
"  methodMirrors { _methodMirrors }\n"
"}\n"
"\n"
"class FiberMirror is ObjectMirror {\n"
"  foreign static methodAt_(reflectee, stackTraceIndex)\n"
"  foreign static lineAt_(reflectee, stackTraceIndex)\n"
"  foreign static stackFramesCount_(reflectee)\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"  }\n"
"\n"
"  lineAt(stackTraceIndex)   { FiberMirror.lineAt_(reflectee, stackTraceIndex) }\n"
"  methodAt(stackTraceIndex) { FiberMirror.methodAt_(reflectee, stackTraceIndex) }\n"
"  stackFramesCount          { FiberMirror.stackFramesCount_(reflectee) }\n"
"\n"
"  stackTrace {\n"
"    var reflectee = this.reflectee\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(reflectee)\n"
"    if (reflectee == Fiber.current) stackFramesCount = stackFramesCount - 1\n"
"    return StackTrace.new_(reflectee, stackFramesCount)\n"
"  }\n"
"}\n"
"\n"
"class MethodMirror is Mirror {\n"
"  foreign static module_(method)\n"
"  foreign static signature_(method)\n"
"\n"
"  construct new_(method/*, classMirror, signature*/) {\n"
"    _method = method\n"
"  }\n"
"\n"
"//  classMirror { Mirror.reflect(MethodMirror.class_(_method)) }\n"
"  moduleMirror { ModuleMirror.fromModule_(MethodMirror.module_(_method)) }\n"
"\n"
"//  arity { MethodMirror.arity_(_method) }\n"
"//  maxSlots { MethodMirror.maxSlots_(_method) }\n"
"//  numUpvalues { MethodMirror.maxSlots_(_numUpvalues) }\n"
"  signature { MethodMirror.signature_(_method) }\n"
"\n"
"  attributes {\n"
"    var attr = ClassMirror.allAttributes(_class)\n"
"    var methods = attr != null ? attr.methods : null\n"
"    return methods != null ? methods[signature] : null\n"
"  }\n"
"}\n"
"\n"
"class ModuleMirror is Mirror {\n"
"  foreign static fromName_(name)\n"
"  foreign static name_(reflectee)\n"
"\n"
"  static fromModule_(module) {\n"
"    return ModuleMirror.new_(module)\n"
"  }\n"
"\n"
"  static fromName(name) {\n"
"    var module = fromName_(name)\n"
"    if (null == module) Fiber.abort(\"Unkown module\")\n"
"\n"
"    return ModuleMirror.fromModule_(module)\n"
"  }\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  name { ModuleMirror.name_(_reflectee) }\n"
"}\n"
"\n"
"class StackTrace {\n"
"  construct new_(fiber, stackFramesCount) {\n"
"    _fiber = fiber\n"
"    _stackTrace = []\n"
"    for (i in 0...stackFramesCount) {\n"
"      _stackTrace.add(StackTraceFrame.new_(fiber, i))\n"
"    }\n"
"  }\n"
"  \n"
"  static new(fiber) {\n"
"    var stackFramesCount = FiberMirror.stackFramesCount_(fiber)\n"
"\n"
"    return new_(fiber, stackFramesCount)\n"
"  }\n"
"\n"
"  frames { _stackTrace }\n"
"  toString { _stackTrace.join(\"\\n\") }\n"
"}\n"
"\n"
"class StackTraceFrame {\n"
"  construct new_(fiber, stackFramesIndex) {\n"
"    _line = FiberMirror.lineAt_(fiber, stackFramesIndex)\n"
"    _methodMirror = MethodMirror.new_(FiberMirror.methodAt_(fiber, stackFramesIndex))\n"
"  }\n"
"\n"
"  line { _line }\n"
"  methodMirror { _methodMirror }\n"
"\n"
"  // toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"  toString { \"at %( _methodMirror.moduleMirror.name ): %( _methodMirror.signature ) line %( _line )\" }\n"
"}\n";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* essentialsModuleSource =
"//#module=essentials\n"
"import \"ensure\" for Ensure\n"
"\n"
"class Strings {\n"
"    static upcase(s) {\n"
"        Ensure.string(s, \"s\")\n"
"        return upcase_(s)\n"
"    }\n"
"    foreign static upcase_(s)\n"
"\n"
"    static downcase(s) {\n"
"        Ensure.string(s, \"s\")\n"
"        return downcase_(s)\n"
"    }\n"
"    foreign static downcase_(s)\n"
"\n"
"    static capitalize(s) {\n"
"        Ensure.string(s, \"s\")\n"
"        if (s.isEmpty) return \"\"\n"
"        if (s.count == 1) return Strings.upcase(s)\n"
"        return Strings.upcase(s[0]) + s[1..-1]\n"
"    }\n"
"\n"
"    static titlecase(s) {\n"
"        Ensure.string(s, \"s\")\n"
"        return s.split(\" \").map {|w| capitalize(downcase(w)) }.join(\" \")\n"
"    }\n"
"\n"
"    /************************************************************************\n"
"     * Adapting the Tcl `string match` command\n"
"     *\n"
"     * Special characters that can appear in a pattern:\n"
"        *\n"
"            Matches any sequence of characters in string, including a null\n"
"            string.\n"
"\n"
"        ?\n"
"            Matches any single character in string.\n"
"\n"
"        [chars]\n"
"            Matches any character in the set given by chars. If a sequence\n"
"            of the form x-y appears in chars, then any character between x\n"
"            and y, inclusive, will match. Ranges can be forward ([a-z]) or\n"
"            backward ([z-a]).\n"
"\n"
"            In somewhat odd behaviour, patterns ending with unclosed\n"
"            bracket expressions will match successfully:\n"
"                Strings.globMatch(\"a\", \"[a]\")   // expect: true\n"
"                Strings.globMatch(\"a\", \"[a\")    // expect: true\n"
"\n"
"            Additionally, \"]\" can appear inside a bracket expression\n"
"            only as the end of a range.\n"
"\n"
"            Empty bracket expressions are always invalid.\n"
"\n"
"        \\\\x\n"
"            Matches the single character x. This provides a way of\n"
"            avoiding the special interpretation of the characters *?[]\\\\ in\n"
"            pattern. In a wren string, the backslash itself must be escaped:\n"
"                Strings.globMatch(\"a*b\", \"a\\\\*b\")   // expect: true\n"
"\n"
"            Use raw strings to reduce the number of backslashes.\n"
"     *\n"
"     */\n"
"    static globMatch(string, pattern) {\n"
"        Ensure.string(string, \"string\")\n"
"        Ensure.string(pattern, \"pattern\")\n"
"        return globMatch_(\n"
"            string,\n"
"            string.count,\n"
"            pattern,\n"
"            pattern.count\n"
"        )\n"
"    }\n"
"\n"
"    foreign static globMatch_(string, strLen, pattern, ptnLen)\n"
"}\n"
"\n"
"\n\n"
"//#module=essentials\n"
"class Time {\n"
"    foreign static now()\n"
"    foreign static highResolution()\n"
"}";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* jsonModuleSource =
"import \"ensure\" for Ensure\n"
"\n"
"// Mainly based on https://github.com/domeengine/dome/blob/develop/src/modules/json.wren\n"
"// Some code based on https://github.com/brandly/wren-json/blob/master/json.wren\n"
"\n"
"class JSONOptions {\n"
"  static nil { 0 }\n"
"  static escapeSolidus { 1 }\n"
"  static abortOnError { 2 }\n"
"  static checkCircular { 4 }\n"
"\n"
"  static contains(options, option) {\n"
"    return ((options & option) != JSONOptions.nil)\n"
"  }\n"
"}\n"
"\n"
"class JSONError {\n"
"  line { _line }\n"
"  position { _position }\n"
"  message { _message }\n"
"  found { _found }\n"
"\n"
"  construct new(line, pos, message, found) {\n"
"    _line = line\n"
"    _position = pos\n"
"    _message = message\n"
"    _found = found\n"
"  }\n"
"\n"
"  static empty() {\n"
"    return JSONError.new(0, 0, \"\", false)\n"
"  }\n"
"}\n"
"\n"
"// pdjson.h:\n"
"\n"
"// enum json_type {\n"
"//     JSON_ERROR = 1, JSON_DONE,\n"
"//     JSON_OBJECT, JSON_OBJECT_END, JSON_ARRAY, JSON_ARRAY_END,\n"
"//     JSON_STRING, JSON_NUMBER, JSON_TRUE, JSON_FALSE, JSON_NULL\n"
"// };\n"
"\n"
"class Token {\n"
"  static isError { 1 }\n"
"  static isDone { 2 }\n"
"  static isObject { 3 }\n"
"  static isObjectEnd { 4 }\n"
"  static isArray { 5 }\n"
"  static isArrayEnd { 6 }\n"
"  static isString { 7 }\n"
"  static isNumeric { 8 }\n"
"  static isBoolTrue { 9 }\n"
"  static isBoolFalse { 10 }\n"
"  static isNull { 11 }\n"
"}\n"
"\n"
"class JSONStream {\n"
"  // Ensure the stream is always a string\n"
"  stream_begin(value) {\n"
"    Ensure.string(value, \"value\")\n"
"    stream_begin_(value)\n"
"  }\n"
"  foreign stream_begin_(value)\n"
"  \n"
"  foreign stream_end()\n"
"  foreign next\n"
"  foreign value\n"
"  foreign error_message\n"
"  foreign lineno\n"
"  foreign pos\n"
"\n"
"  result { _result }\n"
"  error { _error }\n"
"  options { _options }\n"
"  raw { _raw }\n"
"\n"
"  construct new(raw, options) {\n"
"    _result = {}\n"
"    _error = JSONError.empty()\n"
"    _lastEvent = null\n"
"    _raw = raw\n"
"    _options = options\n"
"  }\n"
"\n"
"  begin() {\n"
"    stream_begin(_raw)\n"
"    _result = process(next)\n"
"  }\n"
"\n"
"  end() {\n"
"    stream_end()\n"
"  }\n"
"\n"
"  process(event) {\n"
"    _lastEvent = event\n"
"\n"
"    if (event == Token.isError) {\n"
"      _error = JSONError.new(lineno, pos, error_message, true)\n"
"      if (JSONOptions.contains(_options, JSONOptions.abortOnError)) {\n"
"        end()\n"
"        Fiber.abort(\"JSON error - line %(lineno) pos %(pos): %(error_message)\")\n"
"      }\n"
"      return\n"
"    }\n"
"\n"
"    if (event == Token.isDone) {\n"
"      return\n"
"    }\n"
"\n"
"    if (event == Token.isBoolTrue || event == Token.isBoolFalse) {\n"
"      return (event == Token.isBoolTrue)\n"
"    }\n"
"\n"
"    if (event == Token.isNumeric) {\n"
"      return Num.fromString(this.value)\n"
"    }\n"
"\n"
"    if (event == Token.isString) {\n"
"      return this.value\n"
"    }\n"
"\n"
"    if (event == Token.isNull) {\n"
"      return null\n"
"    }\n"
"\n"
"    if (event == Token.isArray) {\n"
"      var elements = []\n"
"      while (true) {\n"
"        event = next\n"
"        _lastEvent = event\n"
"        if (event == Token.isArrayEnd) {\n"
"          break\n"
"        }\n"
"        elements.add(process(event))\n"
"      }\n"
"      return elements\n"
"    }\n"
"\n"
"    if (event == Token.isObject) {\n"
"      var elements = {}\n"
"      while (true) {\n"
"        event = next\n"
"        _lastEvent = event\n"
"        if (event == Token.isObjectEnd) {\n"
"            break\n"
"        }\n"
"        elements[this.value] = process(next)\n"
"      }\n"
"      return elements\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"// Protocol for JSON encodable objects\n"
"// Prefer this protocol instead of toString\n"
"// Override toJSON in the child\n"
"class JSONEncodable {\n"
"  toJSON {this.toString}\n"
"}\n"
"\n"
"class JSONEscapeChars {\n"
"  static hexchars {[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]}\n"
"\n"
"  static toHex(byte) {\n"
"    var hex = \"\"\n"
"    while (byte > 0) {\n"
"      var c = byte % 16\n"
"      hex = hexchars[c] + hex\n"
"      byte = byte >> 4\n"
"    }\n"
"    return hex\n"
"  }\n"
"  \n"
"  static lpad(s, count, with) {\n"
"    if (s.count < count) {\n"
"      s = \"%(with * (count-s.count))%(s)\"\n"
"    }\n"
"    return s\n"
"  }\n"
"\n"
"  static escape(text, options) {\n"
"    var substrings = []\n"
"    var escapeSolidus = JSONOptions.contains(options, JSONOptions.escapeSolidus)\n"
"    for (char in text) {\n"
"      if (char == \"\\\"\") {\n"
"        substrings.add(\"\\\\\\\"\")\n"
"      } else if (char == \"\\\\\") {\n"
"        substrings.add(\"\\\\\\\\\")\n"
"      } else if (char == \"\\b\") {\n"
"        substrings.add(\"\\\\b\")\n"
"      } else if (char == \"\\f\") {\n"
"        substrings.add(\"\\\\f\")\n"
"      } else if (char == \"\\n\") {\n"
"        substrings.add(\"\\\\n\")\n"
"      } else if (char == \"\\r\") {\n"
"        substrings.add(\"\\\\r\")\n"
"      } else if (char == \"\\t\") {\n"
"        substrings.add(\"\\\\t\")\n"
"      } else if (char.bytes[0] <= 0x1f) {\n"
"        // Control characters!\n"
"        var byte = char.bytes[0]\n"
"        var hex = lpad(toHex(byte), 4, \"0\")\n"
"        substrings.add(\"\\\\u\" + hex)\n"
"      } else if (escapeSolidus && char == \"/\") {\n"
"        substrings.add(\"\\\\/\")\n"
"      } else {\n"
"        substrings.add(char)\n"
"      }\n"
"    }\n"
"    return substrings.join(\"\")\n"
"  }\n"
"}\n"
"\n"
"class JSONEncoder {\n"
"  construct new(options) {\n"
"    _options = options\n"
"    _circularStack = JSONOptions.contains(options, JSONOptions.checkCircular) ? [] : null\n"
"  }\n"
"\n"
"  isCircle(value) {\n"
"    if (_circularStack == null) {\n"
"      return false\n"
"    }\n"
"    return _circularStack.any { |v| Object.same(value, v) }\n"
"  }\n"
"\n"
"  push(value) {\n"
"    if (_circularStack != null) {\n"
"      _circularStack.add(value)\n"
"    }\n"
"  }\n"
"  pop() {\n"
"    if (_circularStack != null) {\n"
"      _circularStack.removeAt(-1)\n"
"    }\n"
"  }\n"
"\n"
"  encode(value) {\n"
"    if (isCircle(value)) {\n"
"      Fiber.abort(\"Circular JSON\")\n"
"    }\n"
"\n"
"    if (value is Num || value is Bool || value is Null) {\n"
"      return value.toString\n"
"    }\n"
"\n"
"    if (value is String) {\n"
"      return \"\\\"\" + JSONEscapeChars.escape(value, _options) + \"\\\"\"\n"
"    }\n"
"\n"
"    if (value is List) {\n"
"      push(value)\n"
"      var substrings = []\n"
"      for (item in value) {\n"
"        substrings.add(encode(item))\n"
"      }\n"
"      pop()\n"
"      return \"[\" + substrings.join(\",\") + \"]\"\n"
"    }\n"
"\n"
"    if (value is Map) {\n"
"      push(value)\n"
"      var substrings = []\n"
"      for (key in value.keys) {\n"
"        var keyValue = this.encode(value[key])\n"
"        var encodedKey = this.encode(key)\n"
"        substrings.add(\"%(encodedKey):%(keyValue)\")\n"
"      }\n"
"      pop()\n"
"      return \"{\" + substrings.join(\",\") + \"}\"\n"
"    }\n"
"\n"
"    // Check if the object implements toJSON\n"
"    if (value is JSONEncodable) {\n"
"      return value.toJSON\n"
"    }\n"
"\n"
"    // Default behaviour is to invoke the toString method\n"
"    return value.toString\n"
"  }\n"
"}\n"
"\n"
"class JSON {\n"
"\n"
"  static encode(value, options) { JSONEncoder.new(options).encode(value) }\n"
"\n"
"  static encode(value) {\n"
"    return JSON.encode(value, JSONOptions.abortOnError)\n"
"  }\n"
"\n"
"  static stringify(value) {\n"
"    return JSON.encode(value)\n"
"  }\n"
"\n"
"  static decode(value, options) {\n"
"    var stream = JSONStream.new(value, options)\n"
"    stream.begin()\n"
"\n"
"    var result = stream.result\n"
"    if (stream.error.found) {\n"
"      result = stream.error\n"
"    }\n"
"\n"
"    stream.end()\n"
"    return result\n"
"  }\n"
"\n"
"  static decode(value) {\n"
"    return JSON.decode(value, JSONOptions.abortOnError)\n"
"  }\n"
"\n"
"  static parse(value) {\n"
"    return JSON.decode(value)\n"
"  }\n"
"}\n";

// Generated automatically from src/modules/*.wren. Do not edit.
static const char* timeModuleSource =
"//#module=time\n"
"class Delorian {\n"
"\n"
"}";

